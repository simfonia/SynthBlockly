# 2026-01-20 工作日誌 (續)

## 問題修復

### 1. 序列埠日誌語系檔缺失修復
- **狀況**：執行 Serial 相關範例時，日誌直接顯示 `LOG_SERIAL_OPENED` 等原始代碼。
- **修正**：於 `js/blocks/lang/en.js` 與 `zh-hant.js` 補齊缺失的翻譯鍵值。

### 2. Audio Engine `updateFilter` 缺失 (TypeError)
- **狀況**：執行範例 12 時，Console 噴出 `updateFilter is not a function` 錯誤。
- **修正**：於 `js/core/audioEngine.js` 中新增 `updateFilter(freq, q)` 方法，支援即時更新濾波器參數。

### 3. Serial Port 連線狀態異常 (InvalidStateError)
- **狀況**：連線失敗後重試會引發 `The port is already closed` 錯誤。
- **修正**：優化 `connectSerial` 與 `disconnectSerial` 的錯誤處理與狀態重置邏輯。

### 4. 範例 12 無 Wah-wah 效果 (Filter Not Created)
- **狀況**：Serial 收到 LDR 資料後，雖然 `updateFilter` 被呼叫，但因濾波器實例從未被建立，導致聲音無變化。
- **原因**：`sb_setup_effect` 積木位於事件監聽器內部。Blockly Manager 在註冊監聽器時，直接移除了 `EFFECT_CONFIG` 註解，卻沒有先根據註解建立效果器鏈。
- **修正**：在 `js/core/blocklyManager.js` 的 `registerListenerForBlock` 中，加入解析 `EFFECT_CONFIG` 並呼蓋 `audioEngine.rebuildEffectChain` 的邏輯。

### 5. 範例 12 數值除錯需求
- **需求**：使用者希望能在 Log 中看到 LDR 數值與轉換後的頻率，確認邏輯正確性。
- **實作**：
    1.  新增 `sb_console_log` 積木定義 (`js/blocks/tools_blocks.js`) 與產生器 (`js/blocks/tools_generators.js`)，將訊息輸出至 `audioEngine.log`。
    2.  修正 Generator 遺漏掛載的問題 (`Uncaught Error`).
    3.  修改 `src/examples/12_wah-wah/12_wah-wah.xml`，插入兩個 `sb_console_log` 積木，分別印出 `Parsed LDR: ...` 與 `Mapped Freq: ...`。

### 6. Log 積木多語系化與名稱優化
- **修正**：將原本的「記錄日誌」改為更直觀的「顯示到訊息區」。
- **實作**：
    1.  於 `en.js` 新增 `SB_CONSOLE_LOG_MESSAGE` ('Log %1')。
    2.  於 `zh-hant.js` 更新 `SB_CONSOLE_LOG_MESSAGE` 為 '顯示到訊息區 %1'。
    3.  更新 `js/blocks/tools_blocks.js` 引用語系鍵值。

### 7. 效果器參數型別容錯處理 (Wah-wah 無效修復)
- **狀況**：範例 12 (Serial Wah-wah) 與範例 6 (Effects) 的效果器功能完全失效。
- **原因**：當 `sb_setup_effect` 的參數使用「變數」而非「純數字」時，Blockly 傳遞給 `rebuildEffectChain` 的參數是變數名稱字串 (例如 `"filterFreq"`)。 Tone.js 的建構子 (例如 `new Tone.Filter(freq)`) 若接收到非數字字串，會導致初始化失敗或參數無效，進而導致效果器鏈失效。
- **修正**：修改 `js/core/audioEngine.js` 中的 `rebuildEffectChain` 方法，加入 `safeNum` 輔助函式。當接收到的參數非數字 (NaN) 時，自動使用預設值進行初始化 (例如 Filter 預設 1000Hz)。
- **結果**：這確保了效果器實例能被正確建立，後續的動態更新 (如 `updateFilter`) 才能針對有效的實例進行操作。

### 8. 「執行程式」導致效果器消失修復
- **狀況**：雖然效果器已在監聽器註冊時建立，但使用者點擊「執行程式 (Run Blocks)」(例如為了啟用 PC 鍵盤) 後，系統會呼叫 `resetAudioEngineState`，這會清空所有的效果器鏈，導致後續的 Serial 事件中找不到 Filter。
- **修正**：在 `js/core/blocklyManager.js` 中實作 `forceRebuildHatEffects()` 函式。
- **邏輯**：當 `getBlocksCode` 被呼叫時，在執行 `resetAudioEngineState` 清空狀態後，立即呼叫 `forceRebuildHatEffects` 掃描所有存在的帽子積木，並根據其中的 `EFFECT_CONFIG` 重新建立效果器鏈。
- **結果**：確保了即使按下執行按鈕，由事件積木定義的效果器依然存在且有效。

### 9. 線性執行 (範例 6) 效果器失效修復
- **狀況**：範例 6 (Effects) 依序設定 Distortion 和 Reverb，但最終只有 Reverb 生效。
- **原因**：`rebuildEffectChain` 會清空當前效果器鏈，導致後續的 `setup` 覆蓋掉前面的設定。此外，對於線性執行，原本的 Generator 只產生註解，不會實際執行建立指令。
- **修正**：
    1.  **Audio Engine**: 新增 `addEffectToChain(config)` 方法，允許將單一效果器加入現有鏈中。
    2.  **Generator**: 修改 `sb_setup_effect` 產生器，使其產生 `window.audioEngine.addEffectToChain(...)` 的執行碼。
    3.  **Blockly Manager**: 在事件監聽器 (`registerListenerForBlock`) 中，濾除 `addEffectToChain` 的執行碼，避免在事件觸發時重複建立效果器。
- **結果**：完美支援了「線性疊加效果器」與「事件定義效果器」兩種模式。

### 11. 範例 14 (Drum Pad) 重構
- **修正**：將原本使用「位元遮罩 (Bitmask)」的複雜邏輯，改為與範例 13 相同的「單鍵字串比對」模式。
- **實作**：更新 XML 邏輯監聽 `KEY:1`~`KEY:4`，並同步更新 `README.md` 指引。

### 12. ADSR 視覺化與發聲同步優化
- **問題**：選取 ADSR 積木進行預覽時會污染引擎狀態，且切換樂器後 UI 與聽感不一致。
- **修正**：
    - 將 `updateADSR` 拆分為引擎狀態更新與 `updateADSRUI` (純繪圖)。
    - 實作「自動同步」：選取積木僅視覺預覽；一旦開始彈奏 (PC Key/MIDI)，UI 自動跳轉回當前活躍樂器的真實設定，確保視覺與聽感一致。

## 待辦事項 (Future V2.0)
- **進階功能**：為 `sb_setup_effect` 增加「指定目標音源 (Target Instrument)」參數，實現更專業的分軌混音能力。
- **架構重構**：考慮導入「定義區 (Definition)」與「執行區 (Execution)」的分離架構，以更穩健地管理樂器與效果器的生命週期。
