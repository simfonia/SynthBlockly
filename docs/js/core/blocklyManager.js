// js/core/blocklyManager.js
import { log } from '../ui/logger.js';
import { registerAll } from '../blocks/index.js'; // New module to handle block registration
import { registerMidiListener, unregisterMidiListener } from './midiEngine.js';

// --- Polyfill to Suppress Deprecation Warning ---
// The user reported seeing a deprecation warning for `Blockly.Workspace.getVariable`.
// This can be caused by built-in blocks or other parts of the library still using the old API.
// To suppress the warning and ensure future compatibility, we override the deprecated function
// and have it call the new API. This was reportedly done before the refactoring.
if (Blockly && Blockly.Workspace && Blockly.Workspace.prototype) {
    if (Blockly.Workspace.prototype.getVariable) {
        Blockly.Workspace.prototype.getVariable = function(name, opt_type) {
            return this.getVariableMap().getVariable(name, opt_type);
        };
    }
    if (Blockly.Workspace.prototype.getAllVariables) {
        Blockly.Workspace.prototype.getAllVariables = function() {
            return this.getVariableMap().getAllVariables();
        };
    }
    if (Blockly.Workspace.prototype.getVariableById) {
        Blockly.Workspace.prototype.getVariableById = function(id) {
            return this.getVariableMap().getVariableById(id);
        };
    }
}

let workspace = null; // Global reference to the Blockly workspace within this module

// --- Workspace Event Handlers (Hat Block Architecture) ---
const blockListeners = {}; // Object to hold listeners for specific blocks, enabling dynamic un-registration

// Expose these globally for block code generated by Blockly, which expects to find them globally.
window.registerSerialDataListener = function (callback) {
    if (typeof callback === 'function') {
        // Only add if not already present to prevent duplicates
        if (!window.__synthBlocklySerialListeners) window.__synthBlocklySerialListeners = [];
        if (!window.__synthBlocklySerialListeners.includes(callback)) {
            window.__synthBlocklySerialListeners.push(callback);
        }
    }
};
window.unregisterSerialDataListener = function (callback) {
    if (window.__synthBlocklySerialListeners) {
        window.__synthBlocklySerialListeners = window.__synthBlocklySerialListeners.filter(listener => listener !== callback);
    }
};


function onWorkspaceChanged(event) {
    if (!workspace) return;
    if (event.isUiEvent) return; // Don't run on UI events like zoom or selection

    // A block was changed, moved, created, or deleted.
    // This is a broad but effective net to catch any changes that might
    // affect the code inside a hat block.
    // Let's find all hat blocks and re-sync their listeners.

    // Find all hat blocks on the workspace
    const serialHats = workspace.getBlocksByType('sb_serial_data_received', false);
    const midiHats = workspace.getBlocksByType('sb_midi_note_received', false);

    // Get a list of all currently registered listener block IDs
    const registeredIds = Object.keys(blockListeners);

    // Combine all current hat blocks
    const allCurrentHats = [...serialHats, ...midiHats];
    const allCurrentHatIds = allCurrentHats.map(b => b.id);

    // Unregister listeners for any hat blocks that have been deleted
    registeredIds.forEach(blockId => {
        if (!allCurrentHatIds.includes(blockId)) {
            if (blockListeners[blockId].type === 'serial') {
                unregisterListenerForBlock(blockId);
            } else if (blockListeners[blockId].type === 'midi') {
                unregisterListenerForMidiBlock(blockId);
            }
        }
    });

    // Re-register all current hat blocks to update their code
    allCurrentHats.forEach(block => {
        // Unregister the old listener for this block ID before registering the new one
        if (blockListeners[block.id]) {
            if (blockListeners[block.id].type === 'serial') {
                unregisterListenerForBlock(block.id);
            } else if (blockListeners[block.id].type === 'midi') {
                unregisterListenerForMidiBlock(block.id);
            }
        }
        
        // Register the new listener
        if (block.type === 'sb_serial_data_received') {
            registerListenerForBlock(block);
        } else if (block.type === 'sb_midi_note_received') {
            registerListenerForMidiBlock(block);
        }
    });
}

function registerListenerForBlock(block) {
    if (!block || blockListeners[block.id]) return; // Already registered

    // --- FIX: Initialize the generator before use ---
    Blockly.JavaScript.init(workspace);

    const code = Blockly.JavaScript.statementToCode(block, 'DO');
    
    // --- FIX: Clean up the generator state after use ---
    Blockly.JavaScript.finish(''); 

    if (!code) return; // No blocks inside the hat

    const variableId = block.getFieldValue('DATA');
    const variable = block.workspace.getVariableMap().getVariableById(variableId);
    if (!variable) return;
    const varData = variable.name;

    try {
        // Wrap the code in an async IIFE to allow await inside the listener
        const listenerFunction = new Function(varData, `(async () => { ${code} })();`);
        window.registerSerialDataListener(listenerFunction);
        blockListeners[block.id] = { type: 'serial', listener: listenerFunction }; // Store type
        log(`即時註冊了積木 ${block.id} 的序列埠監聽器。`);
    } catch (e) {
        console.error("Failed to create or register listener function:", e);
        log(`建立監聽器失敗: ${e.message}`);
    }
}

function unregisterListenerForBlock(blockId) {
    const listenerToRemove = blockListeners[blockId];
    if (listenerToRemove && listenerToRemove.type === 'serial') {
        window.unregisterSerialDataListener(listenerToRemove.listener);
        delete blockListeners[blockId];
        log(`註銷了積木 ${blockId} 的序列埠監聽器。`);
    }
}

function registerListenerForMidiBlock(block) {
    if (!block || blockListeners[block.id]) return; // Already registered

    // Initialize the generator before use
    Blockly.JavaScript.init(workspace);

    const code = Blockly.JavaScript.statementToCode(block, 'DO');
    // Clean up the generator state after use
    Blockly.JavaScript.finish('');

    if (!code) return; // No blocks inside the hat

    const noteVarId = block.getFieldValue('NOTE');
    const velocityVarId = block.getFieldValue('VELOCITY');
    const channelVarId = block.getFieldValue('CHANNEL');

    const noteVar = block.workspace.getVariableMap().getVariableById(noteVarId);
    const velocityVar = block.workspace.getVariableMap().getVariableById(velocityVarId);
    const channelVar = block.workspace.getVariableMap().getVariableById(channelVarId);

    if (!noteVar || !velocityVar || !channelVar) {
        log(`建立 MIDI 監聽器失敗: 變數未找到。`);
        return;
    }
    
    const varNote = noteVar.name;
    const varVelocity = velocityVar.name;
    const varChannel = channelVar.name;

    try {
        // Wrap the code in an async IIFE to allow await inside the listener
        const listenerFunction = new Function(varNote, '_rawVelocity', varChannel, `(async () => {
            const ${varVelocity} = _rawVelocity / 127; // Normalize velocity from 0-127 to 0-1 for Tone.js
            ${code}
        })();`);
        registerMidiListener(listenerFunction);
        blockListeners[block.id] = { type: 'midi', listener: listenerFunction }; // Store type
        log(`即時註冊了積木 ${block.id} 的 MIDI 監聽器。`);
    } catch (e) {
        console.error("Failed to create or register MIDI listener function:", e);
        log(`建立 MIDI 監聽器失敗: ${e.message}`);
    }
}

function unregisterListenerForMidiBlock(blockId) {
    const listenerEntry = blockListeners[blockId];
    if (listenerEntry && listenerEntry.type === 'midi') {
        unregisterMidiListener(listenerEntry.listener);
        delete blockListeners[blockId];
        log(`註銷了積木 ${blockId} 的 MIDI 監聽器。`);
    }
}

/**
 * Initializes Blockly workspace and registers blocks/generators.
 */
export async function initBlocklyManager() {
    log('開始初始化 Blockly...');

    try {
        // Use the new registerAll function to handle all block-related registrations
        const toolboxXml = await registerAll();
        log('✓ 所有模組已載入 (via js/blocks/index.js)');
        
        // Inject Blockly Workspace
        workspace = Blockly.inject('blocklyDiv', {
            toolbox: toolboxXml,
            grid: { spacing: 20, length: 3, colour: '#ccc', snap: true },
            zoom: {
                controls: true,
                wheel: true,
                startScale: 1.0
            },
            move: {
                scrollbars: true,
                drag: true,
                wheel: true
            }
        });
        log('✓ Blockly workspace 已注入');

        // Attach live event listener for hat blocks
        workspace.addChangeListener(onWorkspaceChanged);
        log('✓ 已附加工作區即時事件監聽器。');

    } catch (e) {
        console.error('Blockly initialization failed:', e);
        log('❌ Blockly 初始化失敗: ' + e.message);
    }
}

/**
 * Generates code from the Blockly workspace.
 * @returns {Promise<string>} The generated code.
 */
export async function getBlocksCode() {
    if (!workspace) {
        log('Blockly workspace 尚未初始化');
        return '';
    }
    if (typeof Blockly.JavaScript === 'undefined') {
        log('Blockly.JavaScript 產生器尚未就緒');
        return '';
    }

    try {
        // Ensure the code generator is initialized for this workspace (prevents "init was not called" issues)
        try {
            if (Blockly && Blockly.JavaScript && typeof Blockly.JavaScript.init === 'function') {
                try { Blockly.JavaScript.init(workspace); } catch (e) { console.warn('Blockly.JavaScript.init threw', e); }
            }
        } catch (e) { } // Ignore errors during init

        // Ensure custom generators are in forBlock (Blockly 12+ lookup structure)
        try {
            if (Blockly && Blockly.JavaScript && Blockly.JavaScript.forBlock) {
                const pbsxGens = ['play_note', 'sb_play_drum', 'sb_set_adsr', 'sb_midi_note_received', 'sb_serial_data_received'];
                for (const name of pbsxGens) {
                    if (Blockly.JavaScript[name] && !Blockly.JavaScript.forBlock[name]) {
                        Blockly.JavaScript.forBlock[name] = Blockly.JavaScript[name];
                    }
                }
            }
        } catch (e) { console.warn('forBlock sync failed', e); } // Ignore errors during sync

        let code = Blockly.JavaScript.workspaceToCode(workspace);
        code = Blockly.JavaScript.finish(code);

        if (!code || code.trim() === '') {
            log('產生的程式碼為空');
        } else {
            log('✓ 程式碼已產生（原生 Blockly 產生器）');
        }
        return code;
    } catch (e) {
        console.warn('原生 Blockly 產生器失敗:', e);
        log('備援模式：手動遍歷積木...');
        try {
            Blockly.JavaScript.init(workspace); // Re-initialize the generator for the fallback
            const top = workspace.getTopBlocks(true);
            let out = '';
            const genBlock = function (block) {
                if (!block) return '';
                const t = block.type;
                // 優先嘗試使用 forBlock 中的原生或已註冊產生器
                try {
                    if (Blockly && Blockly.JavaScript && Blockly.JavaScript.forBlock && typeof Blockly.JavaScript.forBlock[t] === 'function') {
                        return Blockly.JavaScript.forBlock[t].call(Blockly.JavaScript, block) || '';
                    }
                } catch (err) { console.warn('forBlock generator failed for', t, err); }
                // 備援：手動實現自訂積木
                if (t === 'sb_play_note') {
                    const note = block.getFieldValue('NOTE') || 'C4';
                    const dur = block.getFieldValue('DUR') || '8n';
                    return "synth.triggerAttackRelease('" + note + "','" + dur + "');\n";
                } else if (t === 'sb_play_drum') {
                    const type = block.getFieldValue('TYPE');
                    if (type === 'KICK') return 'playKick();\n';
                    if (type === 'HH') return "hh.triggerAttackRelease('16n');\n";
                    if (type === 'SNARE') return "(function(){ var sn = new Tone.NoiseSynth({volume:-6}).toDestination(); sn.triggerAttackRelease('8n'); })();\n";
                    return '';
                } else if (t === 'sb_set_adsr') {
                    const a = Number(block.getFieldValue('A')) || 0.01;
                    const d = Number(block.getFieldValue('D')) || 0.1;
                    const s = Number(block.getFieldValue('S')) || 0.5;
                    const r = Number(block.getFieldValue('R')) || 1.0;
                    return "synth.set({envelope: {attack: " + a + ", decay: " + d + ", sustain: " + s + ", release: " + r + "}});\n";
                } else {
                    return '// 不支援的積木類型: ' + t + '\n';
                }
            };
            top.forEach(b => {
                let cur = b;
                while (cur) {
                    out += genBlock(cur);
                    cur = cur.getNextBlock ? cur.getNextBlock() : null;
                }
            });
            if (out.trim() === '') log('備援產生器：產生的程式碼為空');
            else log('✓ 備援產生器成功產生程式碼');
            
            // Call finish() to prepend definitions and setup code
            out = Blockly.JavaScript.finish(out);
            log('✓ 備援產生器完成最終程式碼組合');

            return out;
        } catch (err) {
            console.error('備援產生器錯誤', err);
            log('❌ 備援產生器錯誤: ' + err);
            return '';
        }
    }
}
