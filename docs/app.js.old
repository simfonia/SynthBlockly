// PiBlockly Synth — web/app.js
// 簡易範例：初始化 Blockly、Tone.js 合成器、Web MIDI 與 Web Serial 連線 (基本示範)

import { MSG_EN } from './blocks/en.js';
import { MSG_ZH_HANT } from './blocks/zh-hant.js';

// --- Language Management ---
let currentLanguage = 'en';
let currentMessages = MSG_EN;

// Determine initial language
const userLang = navigator.language || navigator.userLanguage;
if (userLang.includes('zh')) {
    currentLanguage = 'zh-hant';
    currentMessages = MSG_ZH_HANT;
} else {
    currentLanguage = 'en';
    currentMessages = MSG_EN;
}

function updateUITranslations() {
    const elements = document.querySelectorAll('[data-lang-title]');
    elements.forEach(el => {
        const key = el.getAttribute('data-lang-title');
        if (currentMessages[key]) {
            el.title = currentMessages[key];
        }
    });
}

// Function to switch language (can be triggered by a button later)
window.setLanguage = (lang) => {
    currentLanguage = lang;
    if (lang === 'zh-hant') {
        currentMessages = MSG_ZH_HANT;
    } else {
        currentMessages = MSG_EN;
    }
    updateUITranslations();
    // TODO: Also update Blockly toolbox labels if needed
};

// --- Blockly 初始化（等 DOM 載入後注入 toolbox）
let workspace = null;

// --- Tone.js: 合成器與分析器
const synth = new Tone.PolySynth(Tone.Synth).toDestination();
const analyser = new Tone.Analyser('waveform', 1024);
synth.connect(analyser);

// 簡單鼓聲合成（使用 MembraneSynth 與 Noise for hi-hat）
const drum = new Tone.MembraneSynth().toDestination();
const hh = new Tone.NoiseSynth({ volume: -12 }).toDestination();

// log helper
function log(msg) {
    const d = document.getElementById('log');
    d.innerText += msg + '\n';
    d.scrollTop = d.scrollHeight;
}

// --- Audio start handling
let audioStarted = false;
async function ensureAudioStarted() {
    if (audioStarted) return true;
    try {
        await Tone.start(); // 等使用者手勢
        // 若底層 AudioContext 還是 suspended，嘗試 resume
        try { if (Tone.context && Tone.context.state === 'suspended') await Tone.context.resume(); } catch (e) { }
        audioStarted = true;
        log('AudioContext 已啟動');
        return true;
    } catch (e) {
        log('無法啟動 AudioContext: ' + e);
        return false;
    }
}

// MIDI 連線與事件處理
async function connectMIDI() {
    if (!navigator.requestMIDIAccess) { log('瀏覽器不支援 Web MIDI'); return; }
    try {
        const midi = await navigator.requestMIDIAccess();
        for (let input of midi.inputs.values()) {
            input.onmidimessage = onMIDIMessage;
            log('MIDI input ready: ' + input.name);
        }
        midi.onstatechange = (e) => log('MIDI state: ' + e.port.name + ' ' + e.port.state);
    } catch (e) { log('MIDI 連線失敗: ' + e); }
}

function onMIDIMessage(msg) {
    const [status, data1, data2] = msg.data;
    // This function will be defined by the 'midi_received' block
    if (typeof window.onMidiMessage === 'function') {
        window.onMidiMessage(status, data1, data2);
    }
}

// Web Serial 連線與接收（簡單實作）
let serialPort = null;
let serialReader = null;

async function connectSerial() {
    if (!('serial' in navigator)) { log('瀏覽器不支援 Web Serial'); return; }
    try {
        serialPort = await navigator.serial.requestPort();
        await serialPort.open({ baudRate: 115200 });
        log('Serial opened');
        const decoder = new TextDecoderStream();
        serialPort.readable.pipeTo(decoder.writable);
        serialReader = decoder.readable.getReader();
        readSerialLoop();
    } catch (e) { log('Serial error: ' + e); }
}

async function readSerialLoop() {
    try {
        while (true) {
            const { value, done } = await serialReader.read();
            if (done) break;
            if (value) {
                const lines = value.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
                for (const line of lines) handleSerialLine(line);
            }
        }
    } catch (e) { log('Serial read error: ' + e); }
}

function handleSerialLine(line) {
    log('Serial: ' + line);
    // 範例：收到 DRUM:1 / DRUM:KICK 等
    if (line.startsWith('DRUM')) {
        // 分析訊息
        const parts = line.split(':');
        const id = parts[1] ? parts[1].toLowerCase() : 'kick';
        if (id.startsWith('1') || id.includes('kick')) playKick();
        else if (id.includes('hh')) hh.triggerAttackRelease('16n');
        else playKick();
    }
}

function playKick() {
    drum.triggerAttackRelease('C2', '8n');
}

// 測試鍵
document.addEventListener('DOMContentLoaded', () => {
    // 注入 Blockly workspace（toolbox 已內聯於 HTML，generators 由外聯 generators.js 提供）
    try {
        workspace = Blockly.inject('blocklyDiv', {
            toolbox: document.getElementById('toolbox'),
            grid: { spacing: 20, length: 3, colour: '#ccc', snap: true }
        });
        log('Blockly workspace 已注入');

        // 同步註冊 generators（確保在 workspaceToCode 前已註冊）
        if (typeof window.registerPBSGenerators === 'function') {
            window.registerPBSGenerators();
            log('PBS 生成器已同步註冊');
        }

        // 驗證 generators 已註冊
        if (typeof Blockly.JavaScript['pbsx_play_note'] === 'function') {
            log('✓ pbsx_play_note generator 已註冊並可用');
        } else {
            log('⚠ 警告: pbsx_play_note generator 未找到');
        }
    } catch (e) {
        console.error('Blockly 啟動失敗:', e);
        log('Blockly 啟動失敗: ' + e);
    }

    // Resize handler to keep Blockly responsive
    window.addEventListener('resize', () => {
        if (workspace && workspace.svgResize) workspace.svgResize();
    });

    document.getElementById('btnMidi').addEventListener('click', async () => {
        const ok = await ensureAudioStarted();
        if (ok) connectMIDI();
    });
    document.getElementById('btnSerial').addEventListener('click', async () => {
        const ok = await ensureAudioStarted();
        if (ok) connectSerial();
    });
    document.getElementById('btnTestNote').addEventListener('click', async () => {
        const ok = await ensureAudioStarted();
        if (ok) synth.triggerAttackRelease('C4', '8n');
    });

    // 明確的 Start Audio 按鈕：確保在使用者手勢中直接呼叫 Tone.start()
    const startBtn = document.getElementById('btnStartAudio');
    if (startBtn) {
        startBtn.addEventListener('click', async () => {
            try {
                await Tone.start();
                if (Tone.context && Tone.context.state === 'suspended') await Tone.context.resume();
                audioStarted = true;
                log('Audio 已由使用者手動啟動');
            } catch (e) {
                log('啟動 Audio 失敗: ' + e);
            }
        });
    }

    // Handle icon button hover effects
    const iconButtons = document.querySelectorAll('.icon-button');
    iconButtons.forEach(button => {
        const img = button.querySelector('img');
        if (img) {
            const originalSrc = img.src;
            // Assuming icon names follow _1F1F1F.png (default) and _FE2F89.png (hover) pattern
            const hoverSrc = originalSrc.replace('_1F1F1F.png', '_FE2F89.png');

            button.addEventListener('mouseover', () => {
                img.src = hoverSrc;
            });
            button.addEventListener('mouseout', () => {
                img.src = originalSrc;
            });
        }
    });

    // Update UI text based on current language
    updateUITranslations();

    // --- Blockly 產生/執行/匯出處理
    // 產生程式碼：嘗試使用 Blockly.JavaScript 產生器，失敗時使用備援產生器
    async function getBlocksCode() {
        if (!workspace) {
            log('Blockly workspace 尚未初始化');
            return '';
        }
        if (typeof Blockly.JavaScript === 'undefined') {
            log('Blockly.JavaScript 產生器尚未就緒');
            return '';
        }

        // 診斷：檢查 generators 是否存在
        const diagHasNote = typeof Blockly.JavaScript['pbsx_play_note'] === 'function';
        const diagHasDrum = typeof Blockly.JavaScript['pbsx_play_drum'] === 'function';
        const diagHasAdsr = typeof Blockly.JavaScript['pbsx_set_adsr'] === 'function';
        console.log('DEBUG getBlocksCode: pbsx_play_note=', diagHasNote, 'pbsx_play_drum=', diagHasDrum, 'pbsx_set_adsr=', diagHasAdsr);

        // 嘗試使用原生 Blockly 產生器
        try {
            const code = Blockly.JavaScript.workspaceToCode(workspace);
            if (!code || code.trim() === '') {
                log('產生的程式碼為空');
            } else {
                log('✓ 程式碼已產生（原生 Blockly 產生器）');
            }
            return code;
        } catch (e) {
            console.warn('原生 Blockly 產生器失敗:', e.message);
            log('原生產生器失敗，使用備援產生器...');
            log('錯誤: ' + e.message);
            try {
                // 備援：從 workspace 遍歷積木並產生程式碼
                const top = workspace.getTopBlocks(true);
                let out = '';
                const genBlock = function (block) {
                    if (!block) return '';
                    const t = block.type;
                    if (t === 'pbsx_play_note') {
                        const note = block.getFieldValue('NOTE') || 'C4';
                        const dur = block.getFieldValue('DUR') || '8n';
                        return "synth.triggerAttackRelease('" + note + "','" + dur + "');\n";
                    } else if (t === 'pbsx_play_drum') {
                        const type = block.getFieldValue('TYPE');
                        if (type === 'KICK') return 'playKick();\n';
                        if (type === 'HH') return "hh.triggerAttackRelease('16n');\n";
                        if (type === 'SNARE') return "(function(){ var sn = new Tone.NoiseSynth({volume:-6}).toDestination(); sn.triggerAttackRelease('8n'); })();\n";
                        return '';
                    } else if (t === 'pbsx_set_adsr') {
                        const a = Number(block.getFieldValue('A')) || 0.01;
                        const d = Number(block.getFieldValue('D')) || 0.1;
                        const s = Number(block.getFieldValue('S')) || 0.5;
                        const r = Number(block.getFieldValue('R')) || 1.0;
                        return "synth.set({envelope: {attack: " + a + ", decay: " + d + ", sustain: " + s + ", release: " + r + "}});\n";
                    } else {
                        // 嘗試使用 Blockly.JavaScript 產生其他積木
                        try {
                            if (Blockly && Blockly.JavaScript && typeof Blockly.JavaScript[t] === 'function') {
                                return Blockly.JavaScript[t](block) || '';
                            }
                        } catch (err) { }
                        return '// 不支援的積木類型: ' + t + '\n';
                    }
                };
                // 以 top blocks 的順序生成程式碼
                top.forEach(b => {
                    let cur = b;
                    while (cur) {
                        out += genBlock(cur);
                        cur = cur.getNextBlock ? cur.getNextBlock() : null;
                    }
                });
                if (out.trim() === '') log('備援產生器：產生的程式碼為空');
                return out;
            } catch (err) {
                console.error('備援產生器錯誤', err);
                log('備援產生器錯誤: ' + err);
                return '';
            }
        }
    }

    // Run Blocks：將產出的 JS 在全域執行，並將錯誤用 log 顯示
    const runBtn = document.getElementById('btnRunBlocks');
    if (runBtn) {
        runBtn.addEventListener('click', async () => {
            const ok = await ensureAudioStarted();
            if (!ok) return;
            const code = await getBlocksCode();
            if (!code) { log('沒有程式碼可執行'); return; }
            log('執行積木程式碼...');
            try {
                // 建議：避免直接使用 eval，改用 Function 建立隔離作用域
                const runner = new Function('Tone', 'synth', 'drum', 'hh', 'playKick', 'log', code + '\n');
                runner(Tone, synth, drum, hh, playKick, log);
                log('程式執行完畢');
            } catch (e) {
                console.error('RunBlocks execution error', e);
                log('執行積木程式發生錯誤: ' + e);
            }
        });
    }

    // Export Code：顯示並複製到剪貼簿
    const exportBtn = document.getElementById('btnExportCode');
    const codeOut = document.getElementById('codeOut');
    if (exportBtn) {
        exportBtn.addEventListener('click', async () => {
            const code = await getBlocksCode();
            if (!code) { log('沒有程式碼可匯出'); return; }
            codeOut.style.display = 'block';
            codeOut.innerText = code;
            // 複製到剪貼簿
            try { await navigator.clipboard.writeText(code); log('程式碼已複製到剪貼簿'); } catch (e) { log('複製失敗: ' + e); }
            // 同時觸發下載 .js 檔案
            try {
                const blob = new Blob([code], { type: 'text/javascript' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                const ts = new Date().toISOString().replace(/[:.]/g, '-');
                a.href = url;
                a.download = `blockly_export_${ts}.js`;
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
                log('已下載 blockly_export_*.js');
            } catch (e) { log('下載失敗: ' + e); }
        });
    }

    // p5.js instance - waveform 顯示
    new p5((p) => {
        p.setup = function () {
            const container = p.select('#waveformContainer');
            const c = p.createCanvas(container.width, container.height);
            c.parent('waveformContainer');
        };
        p.windowResized = function () {
            const container = p.select('#waveformContainer');
            p.resizeCanvas(container.width, container.height);
        };
        p.draw = function () {
            p.background(16);
            p.noFill();
            p.stroke(0, 200, 255);
            p.strokeWeight(2);
            const vals = analyser.getValue();
            if (!vals) return;
            const h = p.height;
            const w = p.width;
            p.beginShape();
            for (let i = 0; i < vals.length; i++) {
                const x = p.map(i, 0, vals.length, 0, w);
                const y = p.map(vals[i], -1, 1, h, 0);
                p.vertex(x, y);
            }
            p.endShape();
        };
    });
    // 自動在第一次使用者手勢時啟動 AudioContext，避免瀏覽器阻擋
    const oneStart = async function () {
        await ensureAudioStarted();
        document.body.removeEventListener('pointerdown', oneStart);
    };
    document.body.addEventListener('pointerdown', oneStart, { passive: true });
});
