// js/core/blocklyManager.js
import * as Blockly from 'blockly/core';
import 'blockly/javascript';
import { javascriptGenerator } from 'blockly/javascript'; // Explicitly import javascriptGenerator
import { log, logKey } from '../ui/logger.js';
import { registerAll } from '../blocks/index.js'; // Module to handle block registration
import { registerMidiListener, unregisterMidiListener } from './midiEngine.js';
import { audioEngine } from './audioEngine.js'; // Import audioEngine for cleanup functions
// Import the toolbox XML string from its dedicated module.
import { TOOLBOX_XML_STRING } from './toolbox.js';

/*
// --- Polyfill to Suppress Deprecation Warning ---
// The user reported seeing a deprecation warning for `Blockly.Workspace.getVariable`.
// This can be caused by built-in blocks or other parts of the library still using the old API.
// To suppress the warning and ensure future compatibility, we override the deprecated function
// and have it call the new API. This was reportedly done before the refactoring.
if (Blockly && Blockly.Workspace && Blockly.Workspace.prototype) {
    if (Blockly.Workspace.prototype.getVariable) {
        Blockly.Workspace.prototype.getVariable = function(name, opt_type) {
            return this.getVariableMap().getVariable(name, opt_type);
        };
    }
    if (Blockly.Workspace.prototype.getAllVariables) {
        Blockly.Workspace.prototype.getAllVariables = function() {
            return this.getVariableMap().getAllVariables();
        };
    }
    if (Blockly.Workspace.prototype.getVariableById) {
        Blockly.Workspace.prototype.getVariableById = function(id) {
            return this.getVariableMap().getVariableById(id);
        };
    }
}
*/

/**
 * Manually processes the toolbox XML string to replace i18n placeholders.
 * This is a workaround for a bug in production builds where Blockly.inject
 * fails to correctly process the placeholders.
 * @param {string} xmlString The raw XML string with placeholders.
 * @returns {string} The processed XML string with all placeholders replaced.
 */
function processXmlString(xmlString) {
    // This regex finds all placeholders like %{BKY_...}
    return xmlString.replace(/%{BKY_([^}]+)}/g, (match, key) => {
        // Blockly.Msg keys are typically the placeholder key without the 'BKY_' prefix.
        // e.g., %{BKY_MSG_LOGIC_CATEGORY} maps to Blockly.Msg.LOGIC_CATEGORY
        const effectiveKey = key.startsWith('MSG_') ? key.substring(4) : key;
        
        // Return the value from Blockly.Msg if it exists, otherwise return the original placeholder.
        return Blockly.Msg[effectiveKey] || match;
    });
}


let workspace = null; // Global reference to the Blockly workspace within this module

// --- Workspace Event Handlers (Hat Block Architecture) ---
const blockListeners = {}; // Object to hold listeners for specific blocks, enabling dynamic un-registration

// Expose these globally for block code generated by Blockly, which expects to find them globally.
window.registerSerialDataListener = function (callback) {
    if (typeof callback === 'function') {
        // Only add if not already present to prevent duplicates
        if (!window.__synthBlocklySerialListeners) window.__synthBlocklySerialListeners = [];
        if (!window.__synthBlocklySerialListeners.includes(callback)) {
            window.__synthBlocklySerialListeners.push(callback);
        }
    }
};
window.unregisterSerialDataListener = function (callback) {
    if (window.__synthBlocklySerialListeners) {
        window.__synthBlocklySerialListeners = window.__synthBlocklySerialListeners.filter(listener => listener !== callback);
    }
};


function onWorkspaceChanged(event) {
    if (!workspace) return;
    if (event.isUiEvent) return; // Don't run on UI events like zoom or selection

    // A block was changed, moved, created, or deleted.
    // This is a broad but effective net to catch any changes that might
    // affect the code inside a hat block.
    // Let's find all hat blocks and re-sync their listeners.

    // Find all hat blocks on the workspace
    const serialHats = workspace.getBlocksByType('sb_serial_data_received', false);
    const midiHats = workspace.getBlocksByType('sb_midi_note_received', false);

    // Get a list of all currently registered listener block IDs
    const registeredIds = Object.keys(blockListeners);

    // Combine all current hat blocks
    const allCurrentHats = [...serialHats, ...midiHats];
    const allCurrentHatIds = allCurrentHats.map(b => b.id);

    // Unregister listeners for any hat blocks that have been deleted
    registeredIds.forEach(blockId => {
        if (!allCurrentHatIds.includes(blockId)) {
            if (blockListeners[blockId].type === 'serial') {
                unregisterListenerForBlock(blockId);
            } else if (blockListeners[blockId].type === 'midi') {
                unregisterListenerForMidiBlock(blockId);
            }
        }
    });

    // Re-register all current hat blocks to update their code
    allCurrentHats.forEach(block => {
        // Unregister the old listener for this block ID before registering the new one
        if (blockListeners[block.id]) {
            if (blockListeners[block.id].type === 'serial') {
                unregisterListenerForBlock(block.id);
            } else if (blockListeners[block.id].type === 'midi') {
                unregisterListenerForMidiBlock(block.id);
            }
        }

        // Register the new listener
        if (block.type === 'sb_serial_data_received') {
            registerListenerForBlock(block);
        } else if (block.type === 'sb_midi_note_received') {
            registerListenerForMidiBlock(block);
        }
    });
}

function registerListenerForBlock(block) {
    if (!block || blockListeners[block.id]) return; // Already registered

    // --- FIX: Initialize the generator before use ---
    javascriptGenerator.init(workspace);

    const code = javascriptGenerator.statementToCode(block, 'DO');

    // --- FIX: Clean up the generator state after use ---
    javascriptGenerator.finish('');

    if (!code) return; // No blocks inside the hat

    const variableId = block.getFieldValue('DATA');
    const variable = block.workspace.getVariableMap().getVariableById(variableId);
    if (!variable) return;
    const varData = variable.name;

    try {
        // Wrap the code in an async IIFE to allow await inside the listener
        const listenerFunction = new Function(varData, `(async () => { ${code} })();`);
        window.registerSerialDataListener(listenerFunction);
        blockListeners[block.id] = { type: 'serial', listener: listenerFunction }; // Store type
        logKey('LOG_SERIAL_REGISTERED', 'info', block.id);
    } catch (e) {
        console.error("Failed to create or register listener function:", e);
        logKey('LOG_EXEC_ERR', 'error', e.message);
    }
}

function unregisterListenerForBlock(blockId) {
    const listenerToRemove = blockListeners[blockId];
    if (listenerToRemove && listenerToRemove.type === 'serial') {
        window.unregisterSerialDataListener(listenerToRemove.listener);
        delete blockListeners[blockId];
        logKey('LOG_SERIAL_UNREGISTERED', 'info', blockId);
    }
}

function registerListenerForMidiBlock(block) {
    if (!block || blockListeners[block.id]) return; // Already registered

    // Initialize the generator before use
    javascriptGenerator.init(workspace);

    const code = javascriptGenerator.statementToCode(block, 'DO');
    // Clean up the generator state after use
    javascriptGenerator.finish('');

    if (!code) return; // No blocks inside the hat

    const noteVarId = block.getFieldValue('NOTE');
    const velocityVarId = block.getFieldValue('VELOCITY');
    const channelVarId = block.getFieldValue('CHANNEL');

    const noteVar = block.workspace.getVariableMap().getVariableById(noteVarId);
    const velocityVar = block.workspace.getVariableMap().getVariableById(velocityVarId);
    const channelVar = block.workspace.getVariableMap().getVariableById(channelVarId);

    if (!noteVar || !velocityVar || !channelVar) {
        logKey('LOG_MIDI_VAR_ERR', 'error');
        return;
    }

    const varNote = noteVar.name;
    const varVelocity = velocityVar.name;
    const varChannel = channelVar.name;

    try {
        // Wrap the code in an async IIFE to allow await inside the listener
        const listenerFunction = new Function(varNote, '_rawVelocity', varChannel, `(async () => {
            const ${varVelocity} = _rawVelocity / 127; // Normalize velocity from 0-127 to 0-1 for Tone.js
            ${code}
        })();`);
        registerMidiListener(listenerFunction);
        blockListeners[block.id] = { type: 'midi', listener: listenerFunction }; // Store type
        logKey('LOG_MIDI_REGISTERED', 'info', block.id);
    } catch (e) {
        console.error("Failed to create or register MIDI listener function:", e);
        logKey('LOG_EXEC_ERR', 'error', e.message);
    }
}

function unregisterListenerForMidiBlock(blockId) {
    const listenerEntry = blockListeners[blockId];
    if (listenerEntry && listenerEntry.type === 'midi') {
        unregisterMidiListener(listenerEntry.listener);
        delete blockListeners[blockId];
        logKey('LOG_MIDI_UNREGISTERED', 'info', blockId);
    }
}

/**
 * Initializes Blockly workspace and registers blocks/generators.
 */
export async function initBlocklyManager() {
    try {
        // Step 1: Register all blocks, generators, and dynamically load the locale data.
        // This MUST be done first so that Blockly.Msg is populated for logKey to work.
        await registerAll();
        
        // Now that locales are loaded, we can log localized messages.
        logKey('LOG_BLOCKLY_INIT'); 
        logKey('LOG_MODULES_LOADED');

        // Reset audio engine state (now with working localized logs)
        audioEngine.resetAudioEngineState();

        // Step 2: Manually process the toolbox XML string with the now-populated Blockly.Msg
        const processedToolboxXml = processXmlString(TOOLBOX_XML_STRING);
        logKey('LOG_TOOLBOX_PROCESSED');

        // Step 3: Inject Blockly Workspace with the processed and cleaned toolbox XML.
        workspace = Blockly.inject('blocklyDiv', {
            toolbox: processedToolboxXml,
            grid: { spacing: 20, length: 3, colour: '#ccc', snap: true },
            zoom: {
                controls: true,
                wheel: true,
                startScale: 1.0
            },
            move: {
                scrollbars: true,
                drag: true,
                wheel: true
            },
            media: import.meta.env.BASE_URL + 'blockly/media/'
        });
        logKey('LOG_WORKSPACE_INJECTED');

        // Attach live event listener for hat blocks
        workspace.addChangeListener(onWorkspaceChanged);
        logKey('LOG_LISTENERS_ATTACHED');

    } catch (e) {
        console.error('Blockly initialization failed:', e);
        logKey('LOG_BLOCKLY_INIT_FAIL', 'error', e.message);
    }
}

/**
 * Generates code from the Blockly workspace.
 * @returns {Promise<string>} The generated code.
 */
export async function getBlocksCode() {
    if (!workspace) {
        logKey('LOG_WORKSPACE_NOT_INIT', 'error');
        return '';
    }
    if (typeof javascriptGenerator === 'undefined') {
        logKey('LOG_GENERATOR_NOT_READY', 'error');
        return '';
    }

    // 在生成並執行新程式碼之前，先清除舊的音頻狀態
    audioEngine.resetAudioEngineState();

    try {
        // ... [init logic] ...
        try {
            if (javascriptGenerator && typeof javascriptGenerator.init === 'function') {
                try { javascriptGenerator.init(workspace); } catch (e) { console.warn('javascriptGenerator.init threw', e); }
            }
        } catch (e) { } // Ignore errors during init

        // Ensure custom generators are in forBlock (Blockly 12+ lookup structure)
        try {
            if (javascriptGenerator && javascriptGenerator.forBlock) {
                const pbsxGens = ['play_note', 'sb_play_drum', 'sb_set_adsr', 'sb_midi_note_received', 'sb_serial_data_received'];
                for (const name of pbsxGens) {
                    if (javascriptGenerator[name] && !javascriptGenerator.forBlock[name]) {
                        javascriptGenerator.forBlock[name] = javascriptGenerator[name];
                    }
                }
            }
        } catch (e) { console.warn('forBlock sync failed', e); } // Ignore errors during sync

        // --- Dynamic Effect Chain Refactoring ---
        // 1. Collect effect configurations from all 'sb_setup_effect' blocks
        const effectConfigs = [];
        let effectBlocks = workspace.getBlocksByType('sb_setup_effect', false);
        
        // Sort blocks by vertical position to ensure the effect chain matches the visual order
        effectBlocks.sort((a, b) => a.getRelativeToSurfaceXY().y - b.getRelativeToSurfaceXY().y);

        const configRegex = /\/\* EFFECT_CONFIG:(.*?) \*\//;

        effectBlocks.forEach(block => {
            try {
                // Generate the comment string for this block only (opt_thisOnly = true)
                const blockCode = javascriptGenerator.blockToCode(block, true);
                if (blockCode) {
                    const match = blockCode.match(configRegex);
                    if (match && match[1]) {
                        effectConfigs.push(JSON.parse(match[1]));
                    }
                }
            } catch (err) {
                logKey('LOG_EFFECT_BLOCK_ERR', 'error', block.id, err.message);
                console.error(err);
            }
        });

        // 2. Rebuild the audio engine's effect chain based on the collected configs
        // This is done *after* resetting the state and *before* generating the main code.
        audioEngine.rebuildEffectChain(effectConfigs);
        // --- End of Dynamic Effect Chain Refactoring ---

        let code = javascriptGenerator.workspaceToCode(workspace);
        code = javascriptGenerator.finish(code);

        if (!code || code.trim() === '') {
            logKey('LOG_CODE_EMPTY', 'warning');
        } else {
            logKey('LOG_CODE_GENERATED');
        }
        return code;
    } catch (e) {
        console.warn('原生 Blockly 產生器失敗:', e);
        logKey('LOG_FALLBACK_MODE');
        try {
            javascriptGenerator.init(workspace); // Re-initialize the generator for the fallback
            const top = workspace.getTopBlocks(true);
            let out = '';
            const genBlock = function (block) {
                if (!block) return '';
                const t = block.type;
                // 優先嘗試使用 forBlock 中的原生或已註冊產生器
                try {
                    if (javascriptGenerator && javascriptGenerator.forBlock && typeof javascriptGenerator.forBlock[t] === 'function') {
                        return javascriptGenerator.forBlock[t].call(javascriptGenerator, block) || '';
                    }
                } catch (err) { console.warn('forBlock generator failed for', t, err); }
                // 備援：手動實現自訂積木
                if (t === 'sb_play_note') {
                    const note = block.getFieldValue('NOTE') || 'C4';
                    const dur = block.getFieldValue('DUR') || '8n';
                    return "synth.triggerAttackRelease('" + note + "','" + dur + "');\n";
                } else if (t === 'sb_play_drum') {
                    const type = block.getFieldValue('TYPE');
                    if (type === 'KICK') return 'playKick();\n';
                    if (type === 'HH') return "hh.triggerAttackRelease('16n');\n";
                    if (type === 'SNARE') return "(function(){ var sn = new Tone.NoiseSynth({volume:-6}).toDestination(); sn.triggerAttackRelease('8n'); })();\n";
                    return '';
                } else if (t === 'sb_set_adsr') {
                    const a = Number(block.getFieldValue('A')) || 0.01;
                    const d = Number(block.getFieldValue('D')) || 0.1;
                    const s = Number(block.getFieldValue('S')) || 0.5;
                    const r = Number(block.getFieldValue('R')) || 1.0;
                    return "synth.set({envelope: {attack: " + a + ", decay: " + d + ", sustain: " + s + ", release: " + r + "}});\n";
                } else {
                    return '// 不支援的積木類型: ' + t + '\n';
                }
            };
            top.forEach(b => {
                let cur = b;
                while (cur) {
                    out += genBlock(cur);
                    cur = cur.getNextBlock ? cur.getNextBlock() : null;
                }
            });
            if (out.trim() === '') logKey('LOG_FALLBACK_EMPTY', 'warning');
            else logKey('LOG_FALLBACK_SUCCESS');

            // Call finish() to prepend definitions and setup code
            out = javascriptGenerator.finish(out);
            logKey('LOG_FALLBACK_DONE');

            return out;
        } catch (err) {
            console.error('備援產生器錯誤', err);
            logKey('LOG_FALLBACK_ERR', 'error', err);
            return '';
        }
    }
}

/**
 * Clears the Blockly workspace and resets the audio engine state.
 * @returns {void}
 */
export function resetWorkspaceAndAudio() {
    if (workspace) {
        workspace.clear();
        workspace.clearUndo();
        logKey('LOG_WORKSPACE_CLEARED');
    }
    audioEngine.resetAudioEngineState();
    logKey('LOG_ENGINE_RESTARTED');
}
