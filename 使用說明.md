  時間偏移符號的用法詳解

  在 sb_schedule_at_offset 積木的「偏移時間」欄位中，您可以輸入各種 Tone.js
  所能理解的時間表示方式。這些時間都是相對於當前 `sb_tone_loop` 循環開始點的偏移量。

  一、基本音樂時間單位 (以時值命名)

  這是最常用的方式，直接表示音符的時值。數字前綴表示倍數。

   * `'1m'` / `'2m'` / `...`：小節 (Measure)
       * '1m'：一小節。
       * '2m'：兩小節。
   * `'1n'` / `'2n'` / `'4n'` / `'8n'` / `'16n'` / `'32n'` / `...`：全音符及細分 (Note)
       * '1n'：全音符 (Whole Note)。
       * '2n'：二分音符 (Half Note)。
       * '4n'：四分音符 (Quarter Note)。
       * '8n'：八分音符 (Eighth Note)。
       * '16n'：十六分音符 (Sixteenth Note)。
       * '32n'：三十二分音符 (Thirty-second Note)。
   * `'t'` 結尾：三連音 (Triplet)
       * 在音符時值後加上 't' 表示三連音。
       * '8t'：八分三連音 (三個八分音符在兩個八分音符的時間內完成)。
       * '4t'：四分三連音。
   * `.` 結尾：附點音符 (Dotted Note)
       * 在音符時值後加上 . 表示附點音符，使其時值增加一半。
       * '4n.'：附點四分音符。
       * '8n.'：附點八分音符。
   * 秒數 / 毫秒數：`'s'` / `'ms'`
       * '1s'：一秒鐘。
       * '500ms'：五百毫秒。

  範例：
   * '0'：循環開始點 (或 '0s')。
   * '4n'：循環開始點後的四分音符時長。
   * '8t'：循環開始點後的八分三連音時長。
   * '1s'：循環開始點後的一秒鐘。

  ---

  二、小節:拍子:細分 (Measure:Beat:Subdivision) 格式

  這是另一種非常精確且常用的表示法，尤其適合在一個小節內排程複雜的節奏模式。格式為 '小節:拍子:細分'，預設以 4/4
  拍為基準，其中 1 個拍子等於 4 個 16 分音符。

   * `'0:0:0'`：
       * 第一個 0：第 0 小節 (即當前循環的小節)。
       * 第二個 0：第 0 拍 (即第一拍的開始)。
       * 第三個 0：第 0 個細分 (即第一拍的第 1 個 16 分音符)。
       * 總之，`'0:0:0'` 表示當前循環的起始位置 (第一小節第一拍第一個 16 分音符)。

   * `'0:1:0'`：
       * 第 0 小節的第 1 拍 (即第二拍的開始)。

   * `'0:0:2'`：
       * 第 0 小節的第 0 拍（第一拍）的第 2 個細分（即第 3 個 16 分音符）。

  範例：
   * '0' (等同於 '0:0:0')：小節的第一個拍點。
   * '0:1' (等同於 '0:1:0')：小節的第二個拍點。
   * '0:2' (等同於 '0:2:0')：小節的第三個拍點。
   * '0:3' (等同於 '0:3:0')：小節的第四個拍點。
   * '0:0:1'：第一拍的第二個 16 分音符。
   * '0:0:2'：第一拍的第三個 16 分音符。
   * '0:0:3'：第一拍的第四個 16 分音符。
   * '0:1:2'：第二拍的第三個 16 分音符。

  ---

  三、範例：創建一個簡單的搖滾節奏

  假設您的 sb_tone_loop 設定為 每 '1m' 執行 (每小節循環一次)，以下是如何使用 sb_schedule_at_offset 來排程一個簡單的 4/4
  拍搖滾節奏：

   * 大鼓 (Kick - 例如 C1)：
       * 時間偏移：'0' (第一拍)
       * 時間偏移：'0:2' (第三拍)
   * 小鼓 (Snare - 例如 D1)：
       * 時間偏移：'0:1' (第二拍)
       * 時間偏移：'0:3' (第四拍)
   * 踩鈸 (Closed Hi-hat - 例如 F1)：
       * 時間偏移：'0:0:0' (第一拍的第 1 個 16 分音符)
       * 時間偏移：'0:0:2' (第一拍的第 3 個 16 分音符)
       * 時間偏移：'0:1:0' (第二拍的第 1 個 16 分音符)
       * 時間偏移：'0:1:2' (第二拍的第 3 個 16 分音符)
       * 時間偏移：'0:2:0' (第三拍的第 1 個 16 分音符)
       * 時間偏移：'0:2:2' (第三拍的第 3 個 16 分音符)
       * 時間偏移：'0:3:0' (第四拍的第 1 個 16 分音符)
       * 時間偏移：'0:3:2' (第四拍的第 3 個 16 分音符)

  將這些 sb_schedule_at_offset 積木放在 sb_tone_loop 積木內部，並在各自內部放入 jazzkit_play_drum
  積木，就可以創建一個精確的搖滾節奏循環。

  ---

  四、重要注意事項：

   * 所有這些時間偏移都是相對於其父級 `sb_tone_loop` 循環每次迭代的開始時間。
   * 這些排程只有在 Tone.Transport 運行時 (即您使用 啟動指揮 積木後) 才會生效。
   * sb_schedule_at_offset 積木可以放入任何音樂相關的積木，例如 播放音符 (sb_play_note) 來排程旋律或和弦。

  透過這些符號，您可以非常精確地在循環中編排各種音樂事件。


  「設定 ADSR」積木的使用方法

  1. 什麼是 ADSR？

  ADSR 是「音色包絡
  (Envelope)」的四個階段，它描述了聲音從被觸發到完全消失的音量變化過程。透過調整這些參數，您可以塑造音符的特性，讓它們聽
  起來像敲擊樂、弦樂、風琴或其他各種音色。

   * A (Attack - 起動):
       * 從音符被觸發（例如按下琴鍵）到聲音達到最大音量所需的時間。
       * 短 Attack (例如 0.01 秒): 聲音迅速響起，例如打擊樂器或鋼琴。
       * 長 Attack (例如 0.5 秒): 聲音緩慢地從無到有，例如弦樂或パッド (Pad) 音色。

   * D (Decay - 衰減):
       * 聲音從最大音量衰減到持續音量 (Sustain Level) 所需的時間。
       * 短 Decay: 聲音在達到峰值後迅速減弱。
       * 長 Decay: 聲音緩慢減弱，聽起來更自然。

   * S (Sustain - 持續):
       * 聲音在按鍵持續按住期間所維持的音量水平。這個值是一個比率（通常是 0 到 1）。
       * 高 Sustain: 聲音在按鍵按住期間維持較高的音量，例如風琴。
       * 低 Sustain: 聲音快速衰減到較低的音量，但仍持續發聲。

   * R (Release - 釋放):
       * 從按鍵放開後，聲音從持續音量衰減到完全靜止所需的時間。
       * 短 Release: 音符放開後立即停止發聲。
       * 長 Release: 音符放開後聲音緩慢地逐漸消失，產生殘響效果。

  2. 積木的用法：

   1. 從工具箱中拖曳 設定 ADSR 積木到工作區。
   2. 為 A, D, S, R 四個數值欄位輸入您想要的值。
       * A (Attack): 時間，單位秒。範圍通常是 0 到 10，預設為 0.01。
       * D (Decay): 時間，單位秒。範圍通常是 0 到 10，預設為 0.1。
       * S (Sustain): 音量比率，範圍是 0.0 (靜音) 到 1.0 (最大音量)，預設為 0.5。
       * R (Release): 時間，單位秒。範圍通常是 0 到 10，預設為 1.0。

  3. 影響對象：

   * 重要提示： 目前，此 設定 ADSR 積木僅影響預設的合成器 (DefaultSynth / `window.audioEngine.synth`) 的音色包絡。
   * 它不會影響您透過「創建樂器」積木創建的其他自訂合成器（如 AMSynth、FMSynth）或取樣器。
   * 如果您需要為其他自訂樂器設定 ADSR，目前需要另外添加相關的積木功能。

  4. 範例音色設定：

   * 鋼琴般的音色：
       * A = 0.01 (快速啟動)
       * D = 0.2 (快速衰減)
       * S = 0.0 (無持續音，但聲音會根據 Release 持續)
       * R = 0.5 (中等釋放，模擬琴弦共鳴)

   * 弦樂般的音色：
       * A = 0.5 (緩慢啟動)
       * D = 0.8 (緩慢衰減)
       * S = 0.8 (維持較高音量)
       * R = 1.0 (長釋放，模擬弓弦效果)

   * 打擊樂般的音色：
       * A = 0.01 (極速啟動)
       * D = 0.1 (快速衰減)
       * S = 0.0 (無持續音)
       * R = 0.1 (快速釋放)

  您可以嘗試不同的數值組合，來聽聽聲音的變化！


自製取樣
原則上，錄製一個樂器的 C4 音高作為取樣，是一個非常好的開始點。 Tone.js 的 Sampler (取樣器)
  專為此目的設計，它會將你提供的單一音高樣本 (或少量樣本) 進行音高位移，以在整個鍵盤上播放不同的音高。

  然而，為了獲得好的取樣品質，有一些重要的注意事項：

   1. 音高選擇 (C4): 錄製 C4 是製作單一取樣樂器的標準做法。這是因為 C4
      是一個中心音高，取樣器可以從這個基準音高向上或向下準確地調整音高，聽起來會比較自然。
   2. 錄音品質：
       * 清晰度： 在安靜的環境中錄音，避免背景噪音。
       * 純淨度： C4 音符應該清晰可辨，沒有失真。
       * 起始點/結束點： 確保音符的攻擊 (Attack) 和釋放 (Release) 部分沒有被截斷，並且沒有不必要的點擊聲。
   3. 取樣長度：
       * 取樣應該足夠長，以捕捉樂器自然的衰減。太短會聽起來很突然。
       * Tone.Sampler 的 release 參數可以控制按鍵釋放後聲音持續的時間，但它不能彌補過短的原始取樣。
   4. 文件格式： 常見的音訊格式如 .mp3、.wav、.ogg 都可以。
       * .mp3 壓縮率高，檔案小，但可能會引入一些音質損失。
       * .wav 是無損格式，音質最好，但檔案較大。對於單一取樣，通常推薦使用 .wav 獲得最佳音質。
   5. `baseUrl` 和 `urls` 設定：
       * 確保 createInstrument 積木中 Sampler 類型所設定的 baseUrl 指向您放置音訊檔案的目錄。
       * 確保 urls 中的映射使用您錄製的檔案的正確檔名（例如 "C4": "my_piano_c4.mp3"）。

  `Tone.js` Sampler 如何使用單一取樣：
  如果您只提供一個 "C4" 的取樣，Tone.js 會自動調整該取樣的音高和播放速度，以在鍵盤上播放其他音符。這樣做對於接近 C4
  的音符效果最好，但對於距離 C4 太遠的音符（非常高或非常低），聲音聽起來可能會變得不那麼自然或有些失真。



## 音樂創作
SynthBlockly 積木之間沒有嚴格的先後拼接順序，它們更像是各自獨立的「設定指令」。

  您可以把整個系統想像成一個樂器工作站，而這些積木就是您用來調整這個工作站狀態的遙控器。

  各積木的職責（狀態調整）

   1. `<創建樂器>`
       * 作用：在工作站的「樂器庫」中新增一個可用的樂器（例如，創建一個名為 "MyLead" 的 FMSynth）。
       * 使用時機：通常在程式的最開始執行，相當於初始化，先把所有會用到的音色都準備好。

   2. `<選擇樂器>`
       * 作用：告訴工作站：「從現在起，所有播放指令都改用這個樂器」。它設定的是一個全域的「當前音色」狀態。
       * 使用時機：在您想要切換音色時使用。

   3. `<設定 ADSR>`
       * 作用：調整當前所選樂器的聲音包絡（例如，讓它的聲音是短促的還是綿長的）。這個設定會跟隨當前樂器，直到您再次修改
         它。
       * 使用時機：通常在選擇了一個樂器後，用來塑造它的聲音特性。

   4. `<設定效果器>`
       * 作用：調整所有聲音共用的效果器插件的參數。效果器鏈是獨立於樂器的，所有樂器的聲音最終都會流過這個效果器鏈。
       * 使用時機：任何時候。您可以在樂曲的任何段落改變混響的大小、延遲的強度等，來營造不同的氛圍。

  <播放> 積木（觸發聲音）

   * `<播放>` (例如 播放音符, 觸發 MIDI 聲音)
       * 作用：這才是真正「發出聲音」的指令。
       * 執行邏輯：當這個積木被執行時，它會查看工作站的當前狀態：
           1. 「現在選的是哪個樂器？」
           2. 「這個樂器的 ADSR 是什麼設定？」
           3. 「共用的效果器現在是什麼參數？」
           4. 然後根據這些當前狀態，產生最終您聽到的聲音。

  正確的工作流程範例

  因此，一個更靈活、更真實的工作流程是這樣的：

  A. 初始化階段 (在程式開頭執行一次)

   1 創建樂器 "LeadSynth" 型態 "FMSynth"
   2 創建樂器 "PadSynth" 型態 "AMSynth"
   3 設定 Reverb 效果 濕度 0  // 預設關閉所有效果
   4 設定 Delay 效果 濕度 0
  B. 演奏階段 (根據樂曲需要隨時呼叫)

  // --- 主歌部分 ---

   1 選擇目前樂器為 "LeadSynth"
   2 設定 ADSR A 0.01 D 0.2 S 0.9 R 1.0  // 設定一個清脆的音色
   3 設定 Reverb 效果 濕度 0.2 衰減 1.5   // 開一個小混響
   4
   5 播放音符 "C4" ...
   6 播放音符 "E4" ...
  // --- 副歌部分 ---

   1 選擇目前樂器為 "PadSynth"
   2 設定 ADSR A 1.0 D 1.5 S 0.8 R 2.0  // 設定一個慢起音的鋪底音色
   3 設定 Reverb 效果 濕度 0.6 衰減 3.0   // 開一個大混響
   4 設定 Delay 效果 濕度 0.4             // 加入延遲效果
   5
   6 播放和弦 "C4, E4, G4" ...

  總結來說：除了 <創建樂器>
  通常需要最先執行外，其他積木都是獨立的「狀態設定」指令，您可以根據音樂的需要在任何時候使用它們，而不需要將它們嚴格地拼
  接在一起。

## 現場演出
SynthBlockly 的設計完全可以支援這種現場演出的快速切換需求。

  關鍵思路是：將每一套完整的設定（樂器 + ADSR + 效果器）打包成一個「預設 (Preset)」，然後用一個簡單的動作（例如按某個
  MIDI 鍵）來觸發這個「預設」。

  我們將使用「函式」積木來建立「預設」，並使用 當收到 MIDI 音符 積木來設定「觸發器」。

  ---

  現場演出程式的寫法

  假設您的演出需要兩種音色：一個是清脆的鋼琴主音 (Piano Lead)，另一個是氛圍感強烈的弦樂鋪底 (String Pad)。您決定用 MIDI
  鍵盤上最低的兩個音 C1 和 D1 作為切換這兩種音色的「預設切換鍵」。

  您的工作區將會像這樣組織：

  1. 初始化舞台 (Stage Setup)

  這部分積木放在工作區的最頂部，在演出開始前執行一次即可。

   1 [創建樂器 "Piano" 型態 "FMSynth"]
   2 [創建樂器 "Strings" 型態 "AMSynth"]

  2. 定義您的「預設」 (Preset Definitions)

  使用函式積木來定義您的每一個音色設定。

    1 ▼ 函式 [切換到 Piano 音色]
    2    [選擇目前樂器為 "Piano"]
    3    [設定 ADSR A 0.01 D 0.4 S 0.8 R 0.5]
    4    [設定 Reverb 效果 濕度 0.2 衰減 1.2]
    5    [設定 Delay 效果 濕度 0]
    6
    7 ▼ 函式 [切換到 Strings 音色]
    8    [選擇目前樂器為 "Strings"]
    9    [設定 ADSR A 0.8 D 1.2 S 0.9 R 1.5]
   10    [設定 Reverb 效果 濕度 0.8 衰減 5.0]
   11    [設定 Delay 效果 濕度 0.4 Feedback 0.3]
  說明：我們將每一套完整的「樂器選擇 + ADSR + 效果器」參數打包在一個函式中。這個函式就是一個可重複呼叫的「預設」。

  3. 設定「觸發器」 (Trigger Setup)

  使用 當收到 MIDI 音符 積木來監聽您的「預設切換鍵」。

   1 ▼ 當收到 MIDI 音符 [note] 力度 [velocity] 頻道 [channel]
   2    ▼ 如果 [note] = [24]  // C1 的 MIDI 編號是 24
   3       [呼叫 "切換到 Piano 音色"]
   4       [停止預設 MIDI 行為]
   5
   6    ▼ 如果 [note] = [26]  // D1 的 MIDI 編號是 26
   7       [呼叫 "切換到 Strings 音色"]
   8       [停止預設 MIDI 行為]
  說明：
   * 這段程式碼就是您的現場總控台。它會一直在背景監聽所有 MIDI 輸入。
   * 當您按下 C1 鍵，它會立刻執行 切換到 Piano 音色 函式，瞬間將樂器、ADSR、效果器等所有狀態設定完畢。
   * 停止預設 MIDI 行為 積木在這裡至關重要，它能防止您的控制鍵 (C1, D1) 本身發出聲音，讓它們成為純粹的控制訊號。

  如何現場演奏

   1. 準備：在演出前，點擊一次「執行積木」，讓所有初始化和事件監聽（觸發器）都準備就緒。
   2. 演奏：
       * 想用鋼琴音色時，在 MIDI 鍵盤上按一下 `C1` 鍵。
       * 然後您就可以在鍵盤的其他區域（如中央 C 附近）彈奏旋律，所有發出的聲音都會是您設定好的 Piano 音色。
       * 當樂曲進入需要弦樂的段落時，按一下 `D1` 鍵。
       * 您會發現，即使彈奏相同的琴鍵，發出的聲音也瞬間變成了您設定好的、帶有宏大混響的 Strings 音色。

  透過這種「將預設封裝於函式，透過事件觸發函式」的模式，您就可以非常專業、流暢地在現場表演中進行複雜的音色和效果切換。


  LFO：
   1. 主要演奏：由 PC 鍵盤或 MIDI 鍵盤負責彈下音符並持續發聲 (triggerAttack)。
   2. 即時調變：在音符持續的期間，透過 LDR 類比感測器傳來的連續數值，來即時「調變」或「擾動」那個正在發聲的音符的特性。

  這正是合成器中 LFO (低頻振盪器) 的核心玩法，只不過在這裡，您希望用您的「手」來充當這個 LFO，非常酷！

  根據您這個更清晰的目標，我們來重新審視一下需要哪些積木：

  ---

  關於「高通低通效果」

   * 結論：這個功能是可行的，不需要新增積木。
   * 方法：這和我之前說的「想法三：音色魔法師」完全一樣。您只需要把「設定效果器」積木放到「當收到 Serial
     資料」的帽子積木裡面，然後將感測器的數值（經過「映射」積木轉換後）連接到濾波器的「截止頻率」參數上即可。

  ---

  關於「大小聲振盪 (顫音)」和「音準微幅振盪 (抖音)」

   * 結論：這兩個功能目前缺少專用的積木，需要開發。
   * 原因：現有的積木沒有提供即時控制樂器音量 (Volume) 或音高偏移 (Detune)
     的能力。為了實現您想要的用手「揉弦」或「控制音量起伏」的效果，我們需要能即時、連續地修改這些參數的積木。

  我的提案

  為了實現您的演奏方式，我建議為您開發以下 2 個新的積木：

   1. `設定樂器抖音(Vibrato)`
       * 這個積木可以接收一個數值（來自您的感測器），並用它來微調當前樂器的音高。數值大，音高偏移就多；數值小，音高就準
         。

   2. `設定樂器音量(Volume)`
       * 這個積木同樣接收一個數值，用來即時控制當前樂器整體的音量。

  有了這兩個新積木，您就可以在 當收到 Serial 資料 積木中，將感測器數值連接到它們，從而實現您想要的抖音和顫音效果了。

  請問您同意我開始為您開發這兩個新的積木嗎？

> 好的

✦ 使用者已確認要新增「設定樂器抖音(Vibrato)」和「設定樂器音量(Volume)」積木。

  我的計畫是：
   1. 定義積木：在 SynthBlockly/docs/js/blocks/instruments_blocks.js 中使用 jsonInit
      定義每個積木，包含唯一的類型名稱、輸入值欄位、積木結構、文字、工具提示和顏色。
   2. 定義生成器：在 SynthBlockly/docs/js/blocks/instruments_generators.js 中為每個積木創建 Blockly.JavaScript
      生成器函數，將積木轉換為 Tone.js 程式碼，例如設置 currentInstrument 的 detune 或 volume 屬性。
   3. 更新工具箱：將積木添加到 SynthBlockly/docs/toolbox.xml 的 Actions 類別中。

  我將從「設定樂器抖音(Vibrato)」積木開始，首先讀取 SynthBlockly/docs/js/blocks/instruments_blocks.js。
